<?php

namespace App\Http\Controllers\PHP8\P415Observer;

/**
 * Паттерн Observer (наблюдатель) - это поведенческий шаблон проектирования, который позволяет определить зависимость
 * "один-ко-многим" между объектами так, чтобы при изменении состояния одного объекта все зависящие от него объекты
 * были автоматически оповещены и обновлены. Этот паттерн применяется, когда объекты должны быть связаны так, чтобы
 * изменения в одном объекте автоматически приводили к изменениям в других объектах, без явного обращения.
 *
 * В контексте разработки ювелирного интернет-магазина на Laravel, паттерн Observer может быть использован в следующих
 * логических случаях:
 *
 * Уведомления о наличии товаров: Вы можете использовать Observer для создания механизма, который уведомляет клиентов о
 * появлении товаров в наличии. Когда товар становится доступным, Observer может уведомить всех клиентов, оставивших
 * запросы на уведомление о наличии.
 *
 * Уведомления о скидках и акциях: Если ваш магазин предоставляет скидки и акции, Observer может использоваться для
 * автоматической отправки уведомлений о новых акциях и скидках зарегистрированным пользователям.
 *
 * Мониторинг заказов и статусов доставки: Observer может использоваться для отслеживания изменения статуса заказов и
 * автоматической отправки уведомлений клиентам о статусе их заказов (например, "заказ подтвержден", "заказ отправлен"
 * и т. д.).
 *
 * Слежение за интересами клиентов: Паттерн Observer может быть применен для отслеживания предпочтений клиентов и
 * предоставления персонализированных рекомендаций и предложений на основе их поведения и истории покупок.
 *
 * Отслеживание изменений в инвентаре: Observer может быть использован для мониторинга изменений в инвентаре (наличие и
 * количество товаров) и уведомления администраторов магазина о необходимости дополнительных закупок или управления
 * запасами.
 *
 * Laravel предоставляет встроенную поддержку для реализации паттерна Observer с использованием функциональности
 * Eloquent ORM, где вы можете создавать наблюдаемые модели и регистрировать наблюдателей для мониторинга и
 * реагирования на события, происходящие в базе данных.
 */
class ProgramP415Observer
{
    public function index()
    {
        // Создается экземпляр класса `Login`.
        $login = new Login();
        // Вызывается метод `handleLogin` на экземпляре `Login` с аргументами "user", 'pas', '124.5698'. Этот метод имитирует попытку входа пользователя и устанавливает статус входа.
        $login->handleLogin("user", 'pas', '124.5698');
        // Создаются три экземпляра различных классов, которые наследуются от `LoginObserver` и, таким образом, являются наблюдателями: `SecurityMonitor`, `GeneralLogger` и `PartnershipTool`.
        // Каждый из них вызывает метод `doUpdate($login)` с экземпляром `Login` в качестве аргумента.
        // В итоге, при вызове метода `doUpdate($login)` на каждом из наблюдателей, они выполняют свою логику в соответствии с текущим статусом входа, который был установлен методом `handleLogin` в экземпляре `Login`.
        // В данном случае, `SecurityMonitor` выполняет свою логику, так как статус входа установлен как `LOGIN_WRONG_PASS`. `GeneralLogger` и `PartnershipTool` также могут выполнить свою логику, если она связана с определенными статусами входа.
        $securityMonitor = new SecurityMonitor($login);
        $securityMonitor->doUpdate($login);
        $generalLogger = new GeneralLogger($login);
        $generalLogger->doUpdate($login);
        $partnershipTool = new PartnershipTool($login);
        $partnershipTool->doUpdate($login);
    }
}
