# Система контроля версий (VCS)

Система контроля версий (VCS) хранит историю изменений проекта.

## Git

**Git** — самая популярная VCS, используется в IT-командах. Git позволяет контролировать изменения проекта, сохраняя
разные версии кода.

- Система контроля версий помогает анализировать изменения и восстанавливать предыдущие версии.
- Git поддерживает параллельную работу нескольких пользователей над одним проектом.
- Git стал незаменимым инструментом в командной работе благодаря возможности сохранять и "склеивать" труд разных людей.

# Git и GitHub

**Git** — это инструмент для работы с локальными и удалёнными репозиториями.

**GitHub** — популярная платформа для командной работы с использованием Git.

- Git и GitHub — два разных проекта, развивающиеся независимо друг от друга.
- Git — это консольный инструмент, проект с открытым исходным кодом.
- GitHub — платформа для размещения удалённых репозиториев, принадлежит компании Microsoft.

Кроме GitHub, есть и другие платформы для командной работы, такие как **GitLab** и **Bitbucket**.

Git может использоваться и без платформ для создания даже больших проектов.

# SSH и SSH-ключи

**SSH** — протокол для безопасного обмена данными в сети.

## SSH-ключ

**SSH-ключ** — виртуальный идентификатор в **GitHub**, который позволяет получить доступ к репозиторию.

- SSH используется для доступа к другим удалённым серверам.
- SSH-ключ состоит из публичной и приватной частей:
    - **Публичный ключ** шифрует данные.
    - **Приватный ключ** расшифровывает данные.

**Приватный ключ** нельзя передавать, иначе все секреты станут известны.

# Хеширование в Git

**Хеш** — идентификатор коммита в Git.

## Хеширование

**Хеширование** — преобразование набора данных для получения их "отпечатка".

- Хеш коммита получается с помощью алгоритма **SHA-1**.
- Хеш состоит из цифр `0-9` и латинских букв `A-F`.

### Свойства хеша

- Если дважды получить хеш для одного набора данных, результат будет одинаковым.
- Если изменить хоть что-то в исходных данных, хеш изменится.

**Хеш** — основной идентификатор коммита, который позволяет узнать:

- Автора
- Дату
- Содержимое закоммиченных файлов

Хеши и таблицу хешей → информация о коммите **Git** сохраняет в служебных файлах в папке `.git`.

# Файл HEAD в Git

Файл **HEAD** (голова, головной) указывает на последний коммит в системе Git.

- Файл **HEAD** находится в папке `.git`.
- Для проверки содержимого файла **HEAD** можно использовать команду `cat`.

## Содержание файла HEAD

Внутри файла **HEAD** находится ссылка на служебный файл `refs/heads/master`, содержащий хеш последнего коммита.

При работе с Git указатель **HEAD** используется часто. Его можно заменить на слово `HEAD` для передачи последнего
коммита.

# Состояния файлов в Git

В **Git** файлы могут находиться в разных состояниях:

- **Untracked**: новые файлы, не отслеживаемые Git.
- **Staged**: файлы после `git add`, в списке для коммита.
- **Modified**: файлы с изменениями относительно последней версии в staging.
- **Tracked**: файлы, отслеживаемые Git, включая фиксированные и добавленные в staging.

## Жизненный цикл файла

Типичный жизненный цикл файла:

1. Создание
2. Изменение
3. Добавление в staging
4. Коммит
5. Изменение
6. Добавление в staging
7. Коммит

Git предоставляет больше контроля и гибкости в управлении версиями файлов.

# Оформление сообщений к коммитам в Git

Оформление сообщений к коммитам в **Git** может подчиняться определённым правилам, которые могут быть продиктованы
культурой команды или техническими ограничениями.

- В выводе команды `git log --oneline` умещается максимум 72 первых символа сообщения, поэтому многие правила включают
  пункт: «Сообщение не должно быть длиннее 72 символов».

## Популярные подходы к оформлению сообщений коммитов

В этом уроке рассмотрим несколько популярных подходов к оформлению сообщений коммитов:

1. **Единообразие сообщений**: Все люди разные и у всех есть предпочтения, в том числе, как формулировать сообщения
   коммитов. Без единообразия коммитов нет и эффективной работы в Git.

2. **Корпоративный стиль**: В начале сообщения обычно указывают Jira-ID, а после — текст сообщения.

3. **Conventional Commits**: Предлагает такой формат коммита: `<type>: <сообщение>`.

4. **Языковые рекомендации**:
    - Для сообщений на русском языке часто рекомендуют использовать инфинитивы.
    - Для сообщений на английском рекомендуется использовать повелительное наклонение.

# Fork (форк) на GitHub

**Fork** (форк) — операция на **GitHub**, которая создает копию репозитория в аккаунте пользователя.

## Применение Fork

- **Fork** используется для:
    - Внесения вклада в проект
    - Развития проекта независимо от исходного
    - Создания своего проекта на основе чужого

## Как выполнить Fork

1. Перейдите на сайт GitHub.
2. Нажмите на кнопку **Fork** в правом верхнем углу.
3. Создайте копию репозитория.

После создания копии можно вносить изменения и отправлять их в удалённый репозиторий.

## Дополнительные возможности

- **Fork** может быть использован для клонирования репозитория на локальный компьютер.
- **Fork** позволяет получить точную копию репозитория, которая полностью независима от исходного проекта.

# Ветки в Git

**Ветка** — это изолированный поток разработки проекта, который позволяет экспериментировать с проектом и сохранять
репозиторий в стабильном состоянии.

## Преимущества использования веток

- **Ветки полезны**, даже если вы работаете в одиночку, например, над сайтом.
- Основная, стабильная версия проекта хранится в главной ветке `main` или `master`.
- Ветки помогают декомпозировать большую и сложную задачу на маленькие и понятные.

Использование веток позволяет организовать процесс разработки более эффективно и безопасно.

# Ветки в Git

**Ветки** в Git позволяют экспериментировать с проектом и разделять крупные задачи на мелкие.

# Конфликты в Git

**Конфликт** возникает, когда несколько человек модифицируют один и тот же файл, и результаты модификаций оказываются
несовместимыми.

## Причины конфликтов

- Конфликты чаще всего возникают, когда несколько программистов одновременно меняют код в одном и том же месте.

## Обработка конфликтов

- **Git** сам подсвечивает файлы, которые не смог объединить, и предлагает разобраться в ситуации.
- Чтобы разрешить конфликт, нужно:
    1. Изучить обе стороны конфликта.
    2. Собрать две версии в итоговую.
    3. Удалить или подправить неактуальные изменения.

## Риски и управление конфликтами

- Конфликты неизбежны при командной работе, и чем больше веток, тем выше риск возникновения конфликта.
- Главное помнить, что конфликты всегда можно разрешить.

# Работа с ветками в удалённом репозитории

## Работа над задачей в локальной ветке

Работайте над задачей в локальной ветке, чтобы ваши коллеги могли увидеть результат. Обычно изменения загружаются в
новую ветку, а затем вливаются в основную ветку.

## Отправка локальной ветки в удалённый репозиторий

1. **Создайте репозиторий на GitHub** с именем `git-branches`.

2. **Привяжите удалённый репозиторий к локальному** с помощью команды:

    ```bash
    git remote add origin <URL_удалённого_репозитория>
    ```

3. **Отправьте локальную ветку в удалённый репозиторий** с помощью команды:

    ```bash
    git push -u origin <название_ветки>
    ```

4. Для отправки ветки `feature/merge-request` в удалённый репозиторий используйте:

    ```bash
    git push origin feature/merge-request
    ```

5. **Откройте GitHub и обновите страницу**, чтобы увидеть изменения в ветке `feature/merge-request`.

# Pull Request (Пул-реквест)

**Pull Request** — механизм командной работы для внесения изменений в файлы.

## Цель Pull Request

Цель **pull request** — убедиться, что предложенные изменения логичны и эффективны.

## Процесс Pull Request

Процесс **pull request** включает:

1. Создание пул-реквеста
2. Проведение **code review**
3. Слияние изменений

## Состав Pull Request

Пул-реквест состоит из:

- Названия
- Описания
- Исходной ветки
- Целевой ветки

## Создание Pull Request

Есть два способа создания **pull request**:

- Через ссылку Git
- Через интерфейс GitHub

После ревью коллеги могут:

- Принять предложенные изменения
- Вернуть изменения на доработку

# Работа с изменениями в Git

## Работа в команде

В реальных проектах над проектом работают как минимум два разработчика. Когда вы хотите опубликовать свои правки, но у
проекта уже новая версия, нужно обновить свой локальный репозиторий.

## Обновление локального репозитория

1. **Забрать изменения из удалённого репозитория** можно с помощью команды:
 
```bash
    git pull
```

2. Сначала нужно перейти в локальный репозиторий и убедиться, что вы находитесь в правильной ветке.

3. **Git pull** — это первая команда, которую вводит разработчик, как только открывает код проекта.

4. **Git pull** и **git merge** выполняются перед тем, как создать пул-реквест.

5. Команда **git pull** позволяет подтянуть изменения из удалённого репозитория в локальный.


# Fast-Forward в Git

**Fast-forward** в Git — это тип слияния, при котором текущая ветка просто перемещается вперед к коммитам другой ветки без создания нового коммита слияния.

## Условия для Fast-Forward

Это возможно, если:

- Текущая ветка не имеет новых коммитов по сравнению с веткой, в которую выполняется слияние.
- Целевая ветка является прямым предком текущей.

Если в целевой ветке появились новые коммиты, создается новый коммит слияния.

## Отключение Fast-Forward

Отключение **fast-forward** приводит к созданию **merge-коммитов**, которые сохраняют всю информацию о слиянии веток.

**Fast-forward** слияния веток может привести к потере информации, поэтому многие проекты его отключают.


# Fast-Forward и Non-Fast-Forward в Git

## Fast-Forward

**Fast-forward**: коммиты из одной ветки могут быть объединены с коммитами из другой ветки, если:

- Текущая ветка не имеет новых коммитов по сравнению с веткой, в которую выполняется слияние.
- Целевая ветка является прямым предком текущей.

## Non-Fast-Forward

**Non-fast-forward**: коммиты из разных веток не могут быть объединены в одну цепочку, например, если ветки `main` и `add-docs` имеют разошедшиеся истории.

- **Git** проверяет ветки на состояние fast-forward, не учитывая содержимое файлов.
- При слиянии не-fast-forward веток создается **коммит слияния**.

## Конфликты при слиянии

- Конфликты при слиянии возможны.
- **Git** пытается разрешить конфликты автоматически или просит пользователя сделать это вручную.


# Команда `git push` в Git

**Git-команда** `git push` "толкает" коммиты из локальной ветки в удалённую.

## Состояние Fast-Forward

- Состояние **fast-forward** важно для `git push`, но специфическое.
- Локальная и удалённая ветки обычно называются одинаково, но для различения могут использоваться суффиксы.

### Работает ли `git push` без ошибок?

- Если ветки находятся в состоянии **fast-forward**, `git push` сработает без ошибок.
- Если ветки не находятся в состоянии **fast-forward**, `git push` может выдать ошибку.

## Ребазирование и форсированный пуш

- **Ребазирование** позволяет изменить точку, от которой отделилась ветка, и привести её в состояние fast-forward.
- Команда `git push --force` может быть использована для форсированного пуша, но это может привести к конфликтам и "сломать" репозиторий.


# Работа с ветками при командной разработке

## Пуш в main при одиночной работе

- При работе над проектом в одиночку можно "пушить" все изменения в ветку `main`.

## Проблемы при командной работе

- При работе команды из нескольких человек подход "пушить" в `main` становится неудобным.
- Новым сотрудникам нужно время, чтобы влиться в рабочий процесс, и они могут сделать что-то не так из-за незнания.

## Сложности с `git push`

- **Git push** ожидает, что обновление ветки будет происходить в режиме **fast-forward**, но это сложно при активной работе нескольких человек.
- При "пушинге" коммитов в `main`, локальная ветка и ветка на GitHub могут "расходиться" у других участников команды.

## Настройки репозиториев

- В большинстве систем управления репозиториями есть настройка "запретить push в main", которая обычно включена.

## Следующий урок

- В следующем уроке вы узнаете о более эффективных подходах для работы над проектами.


# Подходы к работе с ветками

Подходы к работе с ветками описывают правила создания и слияния коммитов.

## Feature Branch Workflow

**Feature Branch Workflow** — самый простой и популярный подход, где для каждого нового изменения создается новая ветка.

- Позволяет разработчикам трудиться над новыми функциональностями или исправлениями независимо друг от друга.
- В ветке `main` всегда рабочая версия проекта, а все "полуфабрикаты" и недоделанные функциональности находятся в feature-ветках.
- Это шаблон, который можно подстраивать под свои нужды, но ключевая особенность — одна основная ветка и много feature-веток.

## Git Flow

**Git Flow** — более сложный подход, где создается больше веток и коммиты делятся на разные типы.

- Этот подход включает в себя ветки для разработки, релизов и исправлений, что помогает организовать процесс разработки.

## Trunk-Based Development

**Trunk-Based Development** популярен в больших компаниях, где участники проекта вливают свой код в основную ветку максимально часто.

- Этот подход предполагает частое обновление основной ветки (trunk), что помогает поддерживать проект в актуальном состоянии и быстро интегрировать изменения.

## Выбор подхода

Разные компании и команды используют разные модели работы с Git, но все они основаны на создании новых веток для каждой новой функциональности или исправления.


# Feature Branch Workflow

## Процесс работы с feature-ветками

- **Feature Branch Workflow**: новая функциональность разрабатывается в feature-ветках, которые затем вливаются в `main`.
- Перед вливанием в `main`, feature-ветки проходят проверки, включая **code review**.

## Пул-реквест (или мёрж-реквест)

- **Пул-реквест** (или **мёрж-реквест**) — запрос на слияние feature-ветки в `main`.

## Качество изменений

- В некоторых командах строго следят за качеством изменений, в других — проще относятся к тому, что попадает в основную ветку.

## Этап пул-реквеста

- На этапе пул-реквеста возможны автоматические тесты и **code review**.
- **Code review** выполняет две функции:
    1. Проверка качества и необходимости предлагаемых изменений.
    2. Получение информации о новых изменениях в проекте.

## Обсуждение и слияние

- В процессе ревью можно обсуждать предлагаемые изменения и задавать вопросы.
- После одобрения пул-реквеста, автор может нажать кнопку **Merge**, чтобы влить feature-ветку в `main`.


# Навыки специалиста

Навыки специалиста делятся на **hard skills** (жёсткие навыки) и **soft skills** (мягкие навыки).

## Soft Skills

**Soft skills** включают умение договариваться, понимать собеседника и мягко критиковать результаты работы.

## Цель ревью

- Цель ревью — улучшить проект, внести полезные изменения.
- При обсуждении PR важно вносить конструктивные предложения и задавать уточняющие вопросы.

## Поведение ревьюера

- Ревьюер должен уметь выражать мысли понятно и вежливо, предлагать альтернативное решение и не критиковать автора.

## Поведение автора пул-реквеста

- Автору пул-реквеста также важно развивать и применять **soft skills**, чтобы подготовить свой код к ревью.

## Ревью как диалог

- Ревью — это диалог о том, сделают ли конкретные изменения проект лучше.

## Практика и опыт

- Практику невозможно заменить, и освоение ревью на настоящей работе поможет быстро освоиться.


# Конфликты в Git

## Причины возникновения конфликтов

- Конфликты возникают, когда несколько веток изменяют один и тот же файл в разных местах.
- Git не может сам решить, какая версия файла "правильная", поэтому необходимо разрешить конфликт вручную или через инструмент слияния **vimdiff**.

## Разрешение конфликта вручную

- Для разрешения конфликта вручную нужно удалить маркеры конфликтов и оставить только нужные изменения.

## Разрешение конфликта через vimdiff

- Для разрешения конфликта через **vimdiff** нужно вызвать команду `git mergetool`, после чего использовать инструмент **vimdiff** для разрешения конфликта.


# Разрешение конфликтов в Git

## Причины возникновения конфликтов

- Конфликт в Git может возникнуть из-за того, что основная ветка "убежала" вперёд во время ревью.
- Пул-реквест должен пройти ревью, чтобы быть добавленным в основную ветку.
- В это время в `main` вливается ветка другого коллеги, которая попала на ревью раньше вашей.
- Теперь ваши изменения отстают от ветки `main`.

## Разрешение конфликта

- Можно разрешить конфликт автоматически, если GitHub сможет его разрешить.
- Если конфликт не разрешим автоматически, выполните следующие шаги:

    1. Выполните команду `git merge main` для объединения изменений основной ветки с вашей.
    2. Разрешите конфликт локально.
    3. Создайте коммит слияния.
    4. Отправьте новые изменения без конфликтов обратно в удалённый репозиторий с помощью команды `git push`.


# Состояния слияния в Git

В Git есть несколько различных состояний слияния, помимо Fast-Forward. Вот основные из них:

## 1. Fast-Forward

Происходит, когда текущая ветка является предком ветки, которую вы сливаете. Git просто перемещает указатель текущей ветки на последний коммит ветки, которую сливают. Нет необходимости в создании нового коммита слияния.

## 2. Recursive (или Three-Way Merge)

Используется, когда две ветки имеют разные коммиты. Git создает новый коммит, который объединяет изменения из обеих веток. В этом случае происходит создание нового коммита слияния, и вам может понадобиться вручную разрешить конфликты, если они возникли.

## 3. Octopus

Используется для слияния более двух веток одновременно. Подходит для случаев, когда вы хотите объединить несколько веток в одну. Этот метод также создает коммит слияния и может использоваться, если все ветки можно объединить без конфликтов.

## 4. Rebase

Не совсем состояние слияния, но альтернатива слиянию, которая позволяет "переписать" историю ветки. При использовании `rebase`, коммиты из одной ветки "переносится" на вершину другой ветки, что позволяет сохранить более линейную историю.

## 5. Merge Commit

Происходит, когда происходит слияние с созданием нового коммита, который представляет собой результат объединения двух веток. Это может происходить при использовании метода слияния, когда ветки имеют разные коммиты и необходимо создать коммит слияния, чтобы сохранить их историю.


# Стратегии слияния в Git

В Git существуют несколько стратегий слияния, которые применяются в зависимости от конкретной ситуации и требований проекта. Вот краткий обзор основных стратегий:

## 1. Recursive (рекурсивное слияние)

**Описание:** Это стандартная стратегия, которая используется по умолчанию для большинства случаев. При её применении Git сначала пытается выполнить "плоское" слияние, а затем проверяет, можно ли разрешить конфликты, если они возникают.

**Особенности:** Поддерживает слияние нескольких веток (merge of multiple branches). Если есть конфликты, Git создает новый коммит слияния и требует от пользователя разрешения конфликтов.

## 2. Resolve (разрешение)

**Описание:** Это более простая стратегия, которая предполагает, что конфликт будет решен автоматически, если это возможно. Она предназначена для упрощения и ускорения слияния.

**Особенности:** Подходит для простых слияний, когда конфликты могут быть разрешены автоматически.

## 3. Ours (наш)

**Описание:** Эта стратегия игнорирует изменения в ветке, которую вы сливаете, и сохраняет только изменения из текущей ветки.

**Особенности:** Используется, когда вы хотите сохранить текущее состояние ветки, игнорируя изменения, которые могли быть сделаны в сливаемой ветке.

## 4. Octopus (октопус)

**Описание:** Эта стратегия предназначена для слияния более чем двух веток одновременно. Она работает, как рекурсивное слияние, но применительно к нескольким веткам.

**Особенности:** Подходит для объединения нескольких веток в одну.

## 5. Ort (орт)

**Описание:** Это новая стратегия, введенная в Git 2.33, которая заменяет старую стратегию "recursive" и предназначена для улучшения производительности и разрешения конфликтов.

**Особенности:** Обещает лучшее управление памятью и более быструю обработку в больших репозиториях, а также улучшенное разрешение конфликтов.

## 6. Subtree (поддерево)

**Описание:** Эта стратегия позволяет интегрировать один проект (репозиторий) в другой проект как поддерево. Это полезно для проектов, которые включают в себя другие проекты или библиотеки.

**Особенности:** Подходит для случаев, когда вы хотите интегрировать и поддерживать отдельные проекты в рамках одного репозитория.


